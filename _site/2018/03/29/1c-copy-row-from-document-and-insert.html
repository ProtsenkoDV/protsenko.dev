<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Копирование строки табличной части в другой документ в 1С Предприятие 8.3 | Your awesome title</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Копирование строки табличной части в другой документ в 1С Предприятие 8.3" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Скопировать строки табличной части из одного документа в другой не так уж сложно. Кстати, можно копировать как одну строку, так и несколько, а все благодаря свойству объекта - Выделенные строки.Алгоритм следующий: 1. Добавляем реквизиты формы: ДокументЗаявки (или свое что-то там), УдалятьПослеКопирования, и команду копировать ( создается на сервере и клиенте ) 2. На клиенте проверяем заполненность документа заявки 3. Проверяем не является ли ссылка на документ этим же документом, лучше для этого описать функцию которая будет выполняться на сервере, иначе на тонком клиенте работать не будет. 4. Спросим у пользователя, уверен ли он  в своих действиях.&lt;/p&gt; 5. Для избежания возможных ошибок, опишем функцию, допустим ОбновитьДокумент, в нее входит запись документа из которого переносим строку, и повторное его чтение с сервера, это необходимо для перестройки номеров строк после удаления из таблицы. 6. Непосредственно копирование строк должно происходить на сервере, потому что мы получаем документ с сервера, и  в него производим запись. 7. На клиенте получаем массив из выделенных строк, хочу заметить что массив наполнен значениями номера строк в том порядке как вы их выбирали, к примеру 5, 2 , 6 , 0. Это важно учитывать если вы собираетесь после копирования удалять строки из табличной части. Можно остановится и задуматься. Почему важно? Потому что удалив из таблицы конкретный элемент массива, то произойдет перерасчет номера строки, и если первым делом удален 5 элемент, то 6 элемент индекса уже будет пятым, и т.д., то есть все после 5 индекса уменьшится на одну единицу, а массив выделенных строк нет, поэтому при удалении лучше удалять элементы с конца к начала, а не как в массиве, т.е. нужно отсортировать по убыванию массив выделенных строк. Кстати массив выделенных строк отправим аргументом процедуры на сервер. 8. Перейдем к копированию на сервере, на этом этапе можно столкнуться с ошибка при обращении к элементу формы. Для того чтобы с формы передать на сервер данные - необходимо вызвать функцию РеквизитФормыВЗначение. 9. Получаем документ в который будем копировать строки, а далее дело за малым. 10. Циклом проходим по всем выделенным фрагментам. 10. У документа реципиента добавляем строку табличной части 11. В теле цикла Заполняем значения свойств созданной строки - значением строки из копируемого документа по номеру элемента. 12. Записываем изменения. 13. С удалением проблем не будет, массив выделенных строк сортируем, и пройдя по массиву удаляем из таблицы необходимый  индекс. На этом все, код который можно стырить, потрогать, пощупать, внедрить, переделать и вставить поглубже в конфигуратор тут" />
<meta property="og:description" content="Скопировать строки табличной части из одного документа в другой не так уж сложно. Кстати, можно копировать как одну строку, так и несколько, а все благодаря свойству объекта - Выделенные строки.Алгоритм следующий: 1. Добавляем реквизиты формы: ДокументЗаявки (или свое что-то там), УдалятьПослеКопирования, и команду копировать ( создается на сервере и клиенте ) 2. На клиенте проверяем заполненность документа заявки 3. Проверяем не является ли ссылка на документ этим же документом, лучше для этого описать функцию которая будет выполняться на сервере, иначе на тонком клиенте работать не будет. 4. Спросим у пользователя, уверен ли он  в своих действиях.&lt;/p&gt; 5. Для избежания возможных ошибок, опишем функцию, допустим ОбновитьДокумент, в нее входит запись документа из которого переносим строку, и повторное его чтение с сервера, это необходимо для перестройки номеров строк после удаления из таблицы. 6. Непосредственно копирование строк должно происходить на сервере, потому что мы получаем документ с сервера, и  в него производим запись. 7. На клиенте получаем массив из выделенных строк, хочу заметить что массив наполнен значениями номера строк в том порядке как вы их выбирали, к примеру 5, 2 , 6 , 0. Это важно учитывать если вы собираетесь после копирования удалять строки из табличной части. Можно остановится и задуматься. Почему важно? Потому что удалив из таблицы конкретный элемент массива, то произойдет перерасчет номера строки, и если первым делом удален 5 элемент, то 6 элемент индекса уже будет пятым, и т.д., то есть все после 5 индекса уменьшится на одну единицу, а массив выделенных строк нет, поэтому при удалении лучше удалять элементы с конца к начала, а не как в массиве, т.е. нужно отсортировать по убыванию массив выделенных строк. Кстати массив выделенных строк отправим аргументом процедуры на сервер. 8. Перейдем к копированию на сервере, на этом этапе можно столкнуться с ошибка при обращении к элементу формы. Для того чтобы с формы передать на сервер данные - необходимо вызвать функцию РеквизитФормыВЗначение. 9. Получаем документ в который будем копировать строки, а далее дело за малым. 10. Циклом проходим по всем выделенным фрагментам. 10. У документа реципиента добавляем строку табличной части 11. В теле цикла Заполняем значения свойств созданной строки - значением строки из копируемого документа по номеру элемента. 12. Записываем изменения. 13. С удалением проблем не будет, массив выделенных строк сортируем, и пройдя по массиву удаляем из таблицы необходимый  индекс. На этом все, код который можно стырить, потрогать, пощупать, внедрить, переделать и вставить поглубже в конфигуратор тут" />
<link rel="canonical" href="http://localhost:4000/2018/03/29/d0-ba-d0-be-d0-bf-d0-b8-d1-80-d0-be-d0-b2-d0-b0-d0-bd-d0-b8-d0-b5-d1-81-d1-82-d1-80-d0-be-d0-ba-d0-b8-d1-82-d0-b0-d0-b1-d0-bb-d0-b8-d1-87-d0-bd-d0-be-d0-b9-d1-87-d0-b0-d1-81-d1-82-d0-b8-d0-b2.html" />
<meta property="og:url" content="http://localhost:4000/2018/03/29/d0-ba-d0-be-d0-bf-d0-b8-d1-80-d0-be-d0-b2-d0-b0-d0-bd-d0-b8-d0-b5-d1-81-d1-82-d1-80-d0-be-d0-ba-d0-b8-d1-82-d0-b0-d0-b1-d0-bb-d0-b8-d1-87-d0-bd-d0-be-d0-b9-d1-87-d0-b0-d1-81-d1-82-d0-b8-d0-b2.html" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-29T13:37:00+05:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/03/29/d0-ba-d0-be-d0-bf-d0-b8-d1-80-d0-be-d0-b2-d0-b0-d0-bd-d0-b8-d0-b5-d1-81-d1-82-d1-80-d0-be-d0-ba-d0-b8-d1-82-d0-b0-d0-b1-d0-bb-d0-b8-d1-87-d0-bd-d0-be-d0-b9-d1-87-d0-b0-d1-81-d1-82-d0-b8-d0-b2.html"},"@type":"BlogPosting","url":"http://localhost:4000/2018/03/29/d0-ba-d0-be-d0-bf-d0-b8-d1-80-d0-be-d0-b2-d0-b0-d0-bd-d0-b8-d0-b5-d1-81-d1-82-d1-80-d0-be-d0-ba-d0-b8-d1-82-d0-b0-d0-b1-d0-bb-d0-b8-d1-87-d0-bd-d0-be-d0-b9-d1-87-d0-b0-d1-81-d1-82-d0-b8-d0-b2.html","headline":"Копирование строки табличной части в другой документ в 1С Предприятие 8.3","dateModified":"2018-03-29T13:37:00+05:00","datePublished":"2018-03-29T13:37:00+05:00","description":"Скопировать строки табличной части из одного документа в другой не так уж сложно. Кстати, можно копировать как одну строку, так и несколько, а все благодаря свойству объекта - Выделенные строки.Алгоритм следующий: 1. Добавляем реквизиты формы: ДокументЗаявки (или свое что-то там), УдалятьПослеКопирования, и команду копировать ( создается на сервере и клиенте ) 2. На клиенте проверяем заполненность документа заявки 3. Проверяем не является ли ссылка на документ этим же документом, лучше для этого описать функцию которая будет выполняться на сервере, иначе на тонком клиенте работать не будет. 4. Спросим у пользователя, уверен ли он  в своих действиях.&lt;/p&gt; 5. Для избежания возможных ошибок, опишем функцию, допустим ОбновитьДокумент, в нее входит запись документа из которого переносим строку, и повторное его чтение с сервера, это необходимо для перестройки номеров строк после удаления из таблицы. 6. Непосредственно копирование строк должно происходить на сервере, потому что мы получаем документ с сервера, и  в него производим запись. 7. На клиенте получаем массив из выделенных строк, хочу заметить что массив наполнен значениями номера строк в том порядке как вы их выбирали, к примеру 5, 2 , 6 , 0. Это важно учитывать если вы собираетесь после копирования удалять строки из табличной части. Можно остановится и задуматься. Почему важно? Потому что удалив из таблицы конкретный элемент массива, то произойдет перерасчет номера строки, и если первым делом удален 5 элемент, то 6 элемент индекса уже будет пятым, и т.д., то есть все после 5 индекса уменьшится на одну единицу, а массив выделенных строк нет, поэтому при удалении лучше удалять элементы с конца к начала, а не как в массиве, т.е. нужно отсортировать по убыванию массив выделенных строк. Кстати массив выделенных строк отправим аргументом процедуры на сервер. 8. Перейдем к копированию на сервере, на этом этапе можно столкнуться с ошибка при обращении к элементу формы. Для того чтобы с формы передать на сервер данные - необходимо вызвать функцию РеквизитФормыВЗначение. 9. Получаем документ в который будем копировать строки, а далее дело за малым. 10. Циклом проходим по всем выделенным фрагментам. 10. У документа реципиента добавляем строку табличной части 11. В теле цикла Заполняем значения свойств созданной строки - значением строки из копируемого документа по номеру элемента. 12. Записываем изменения. 13. С удалением проблем не будет, массив выделенных строк сортируем, и пройдя по массиву удаляем из таблицы необходимый  индекс. На этом все, код который можно стырить, потрогать, пощупать, внедрить, переделать и вставить поглубже в конфигуратор тут","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">О авторе</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Копирование строки табличной части в другой документ в 1С Предприятие 8.3</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-03-29T13:37:00+05:00" itemprop="datePublished">Mar 29, 2018
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"Dima Protsenko", "login"=>"Dima Protsenko", "email"=>"", "url"=>""}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div dir="ltr" style="text-align: left;">Скопировать строки табличной части из одного документа в другой не так уж сложно.<br />
Кстати, можно копировать как одну строку, так и несколько, а все благодаря свойству объекта - Выделенные строки.Алгоритм следующий:<br />
1. Добавляем реквизиты формы: ДокументЗаявки (или свое что-то там), УдалятьПослеКопирования, и команду копировать ( создается на сервере и клиенте )<br />
2. На клиенте проверяем заполненность документа заявки<br />
3. Проверяем не является ли ссылка на документ этим же документом, лучше для этого описать функцию которая будет выполняться на сервере, иначе на тонком клиенте работать не будет.<br />
4. Спросим у пользователя, уверен ли он  в своих действиях.</p>
<p><a name="more"></a>5. Для избежания возможных ошибок, опишем функцию, допустим ОбновитьДокумент, в нее входит запись документа из которого переносим строку, и повторное его чтение с сервера, это необходимо для перестройки номеров строк после удаления из таблицы.<br />
6. Непосредственно копирование строк должно происходить на сервере, потому что мы получаем документ с сервера, и  в него производим запись.<br />
7. На клиенте получаем массив из выделенных строк, хочу заметить что массив наполнен значениями номера строк в том порядке как вы их выбирали, к примеру 5, 2 , 6 , 0. Это важно учитывать если вы собираетесь после копирования удалять строки из табличной части.<br />
Можно остановится и задуматься.<br />
Почему важно? Потому что удалив из таблицы конкретный элемент массива, то произойдет перерасчет номера строки, и если первым делом удален 5 элемент, то 6 элемент индекса уже будет пятым, и т.д., то есть все после 5 индекса уменьшится на одну единицу, а массив выделенных строк нет, поэтому при удалении лучше удалять элементы с конца к начала, а не как в массиве, т.е. нужно отсортировать по убыванию массив выделенных строк.<br />
Кстати массив выделенных строк отправим аргументом процедуры на сервер.<br />
8. Перейдем к копированию на сервере, на этом этапе можно столкнуться с ошибка при обращении к элементу формы. Для того чтобы с формы передать на сервер данные - необходимо вызвать функцию РеквизитФормыВЗначение.<br />
9. Получаем документ в который будем копировать строки, а далее дело за малым.<br />
10. Циклом проходим по всем выделенным фрагментам.<br />
10. У документа реципиента добавляем строку табличной части<br />
11. В теле цикла Заполняем значения свойств созданной строки - значением строки из копируемого документа по номеру элемента.<br />
12. Записываем изменения.<br />
13. С удалением проблем не будет, массив выделенных строк сортируем, и пройдя по массиву удаляем из таблицы необходимый  индекс.<br />
На этом все, код который можно стырить, потрогать, пощупать, внедрить, переделать и вставить поглубже в конфигуратор <a href="https://github.com/ProtsenkoDV/thesilverwolf/blob/master/1C/copy%20row.txt" target="_blank" rel="nofollow noopener noreferrer">тут </a></p>
</div>

  </div><a class="u-url" href="/2018/03/29/d0-ba-d0-be-d0-bf-d0-b8-d1-80-d0-be-d0-b2-d0-b0-d0-bd-d0-b8-d0-b5-d1-81-d1-82-d1-80-d0-be-d0-ba-d0-b8-d1-82-d0-b0-d0-b1-d0-bb-d0-b8-d1-87-d0-bd-d0-be-d0-b9-d1-87-d0-b0-d1-81-d1-82-d0-b8-d0-b2.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
